<!-- Copyright (C) Bandicoot Imaging Sciences 2019 -->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <!-- Disable favicon request until we make an icon -->
    <link rel="icon" href="data:,">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Bivot material viewer</title>

    <!-- 
      Parts of this script were adapted from third party code. Refer to LICENSE-third_party.md for the
      relevant licenses.

      Parts adapted from Threejs:
      - EXR texture loading.
      https://github.com/mrdoob/three.js/blob/dev/examples/webgl_loader_texture_exr.html

      Parts adapted from Threejsfundamentals:
      - Responsive layout
      - On demand rendering
      - Initial HTML and JS structure
      - Texture loading progress bar.
        https://github.com/greggman/threejsfundamentals/blob/master/threejs/threejs-render-on-demand-w-gui.html
        https://github.com/greggman/threejsfundamentals/blob/master/threejs/threejs-textured-cube-wait-for-all-textures.html
    -->

    <style>
    body {
        margin: 0;
    }
    #c {
        width: 100vw;
        height: 100vh;
        display: block;
    }
    #loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #loading .progress {
        margin: 1.5em;
        border: 1px solid white;
        width: 50vw;
    }
    #loading .progressbar {
        margin: 2px;
        background: white;
        height: 1em;
        transform-origin: top left;
        transform: scaleX(0);
    }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div id="loading">
      <div class="progress"><div class="progressbar"></div></div>
    </div>
  </body>
<script src="third_party/threejs/three.min.js"></script>
<script src="third_party/threejs/js/controls/OrbitControls.js"></script>
<script src="third_party/threejs/js/loaders/EXRLoader.js"></script>
<script src="third_party/threejs/js/libs/dat.gui.min.js"></script>
<script src="third_party/threejs/js/WebGL.js"></script>
<script>
'use strict';

function main() {
  let state = {
    exposure: 2.0
  };

  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});

  renderer.toneMapping = THREE.ReinhardToneMapping;
  renderer.toneMappingExposure = state.exposure/10000;

  const fov = 35;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 5;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.z = 2;

  const controls = new THREE.OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.rotateSpeed = 0.1;
  controls.target.set(0, 0, 0);
  controls.update();

  const gui = new dat.GUI();
  gui.add(state, 'exposure', 0, 20, 0.01).onChange(render);
  gui.open();

  const scene = new THREE.Scene();
  
  scene.background = new THREE.Color(0x222222);

  const color = 0xFFFFFF;
  const intensity = 1;
  const light = new THREE.DirectionalLight(color, intensity);
  light.position.set(-1, 2, 4);
  scene.add(light);

  // const matxs = 1928;
  // const matys = 1285;
  // const padxs = 2048;
  // const padys = padxs;
  const planeWidth = 1;
  // const planeHeight = matys/matxs;
  const planeHeight = 1;
  const geometry = new THREE.PlaneBufferGeometry(planeWidth, planeHeight);

  const loadManager = new THREE.LoadingManager();
  const loader = new THREE.EXRLoader(loadManager);
  let material = null;

  const texture = loader.load('textures/coffee-matte/brdf-diffuse_padf16.exr',
    function (texture, textureData) {
      // Run after each texture is loaded.
      console.log('Loaded:', textureData);
      console.log('Loaded:', texture);
      // Mip map filtering doesn't seem to work for EXR textures. WebGL complains: RENDER WARNING: texture
      // bound to texture unit 0 is not renderable. It maybe non-power-of-2 and have incompatible texture
      // filtering.
      texture.minFilter = THREE.NearestFilter;
      texture.magFilter = THREE.NearestFilter;
      // Flip from chart space back into camera view space.
      texture.flipY = true;
      // iOS does not support WebGL2
      // Textures need to be square powers of 2 for WebGL1
      // texture.repeat.set(matxs/padxs, matxs/padys);
      material = new THREE.MeshBasicMaterial({map: texture});
    }
  );

  const loadingElem = document.querySelector('#loading');
  const progressBarElem = loadingElem.querySelector('.progressbar');

  loadManager.onLoad = () => {
    // Run after all textures are loaded.
    loadingElem.style.display = 'none';
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    render();
  };

  loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
    const progress = itemsLoaded / itemsTotal;
    progressBarElem.style.transform = `scaleX(${progress})`;
  };

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const pixelRatio = window.devicePixelRatio;
    const width  = canvas.clientWidth  * pixelRatio | 0;
    const height = canvas.clientHeight * pixelRatio | 0;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  let renderRequested = false;

  function render() {
    renderRequested = undefined;

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    controls.update();
    renderer.toneMappingExposure = state.exposure/10000;
    renderer.render(scene, camera);
  }
  render();

  function requestRenderIfNotRequested() {
    if (!renderRequested) {
      renderRequested = true;
      requestAnimationFrame(render);
    }
  }

  controls.addEventListener('change', requestRenderIfNotRequested);
  window.addEventListener('resize', requestRenderIfNotRequested);
}

if ( WEBGL.isWebGLAvailable() === false ) {
    document.body.appendChild( WEBGL.getWebGLErrorMessage() );
}

main();
</script>
</html>

