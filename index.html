<!-- Copyright (C) Bandicoot Imaging Sciences 2019 -->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <!-- Disable favicon request until we make an icon -->
    <link rel="icon" href="data:,">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Bivot material viewer</title>

    <!-- 
      Parts of this script were adapted from third party code. Refer to LICENSE-third_party.md for the
      relevant licenses.

      Parts adapted from Threejs:
      - EXR texture loading.
      https://github.com/mrdoob/three.js/blob/dev/examples/webgl_loader_texture_exr.html

      Parts adapted from Threejsfundamentals:
      - Responsive layout
      - On demand rendering
      - Initial HTML and JS structure
      - Texture loading progress bar.
        https://github.com/greggman/threejsfundamentals/blob/master/threejs/threejs-render-on-demand-w-gui.html
        https://github.com/greggman/threejsfundamentals/blob/master/threejs/threejs-textured-cube-wait-for-all-textures.html
    -->

    <style>
    body {
        margin: 0;
    }
    #c {
        width: 100vw;
        height: 100vh;
        display: block;
    }
    #loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #loading .progress {
        margin: 1.5em;
        border: 1px solid white;
        width: 50vw;
    }
    #loading .progressbar {
        margin: 2px;
        background: white;
        height: 1em;
        transform-origin: top left;
        transform: scaleX(0);
    }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div id="loading">
      <div class="progress"><div class="progressbar"></div></div>
    </div>
  </body>
<script src="third_party/threejs/three.min.js"></script>
<script src="third_party/threejs/js/controls/OrbitControls.js"></script>
<script src="third_party/threejs/js/loaders/EXRLoader.js"></script>
<script src="third_party/threejs/js/libs/dat.gui.min.js"></script>
<script src="third_party/threejs/js/WebGL.js"></script>
<script src="third_party/threejs/js/libs/stats.min.js"></script>
<script>
'use strict';

function main() {
  let state = {
    exposure: 2.0
  };
  let exposureGain = 1/10000;
  // let exposureGain = 1;

  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});

  renderer.toneMapping = THREE.ReinhardToneMapping;
  renderer.toneMappingExposure = exposureGain*state.exposure;

  // Physical distance units are in metres.
  const focalLength = 0.085;
  const sensorWidth = 0.036;
  const fov = 2*Math.tan(sensorWidth/focalLength)*180/Math.PI;
  const aspect = 2;  // the canvas default
  const near = 0.01;
  const far = 10;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.set(0, 0, 0.1);

  const controls = new THREE.OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  // FIXME: Panning speed is too touchy. The statement below didn't seem to have any effect.
  // controls.userPanSpeed = 0.01;
  controls.rotateSpeed = 0.1;
  controls.target.set(0, 0, 0);
  controls.update();

  const gui = new dat.GUI();
  gui.add(state, 'exposure', 0, 20, 0.01).onChange(render);
  gui.open();

  const scene = new THREE.Scene();
  
  scene.background = new THREE.Color(0x222222);

  const color = 0xFFFFFF;
  const intensity = 1;
  const light = new THREE.PointLight(color, intensity);
  light.position.set(1, 0, 1);
  scene.add(light);

  const dpi = 300;
  const pixelsPerMetre = dpi/0.0254;
  const textureWidthPixels = 512;
  const textureHeightPixels = 512;
  // const matxs = 1928;
  // const matys = 1285;
  // const padxs = 2048;
  // const padys = padxs;
  // const planeHeight = matys/matxs;
  const planeWidth = textureWidthPixels/pixelsPerMetre;
  const planeHeight = textureHeightPixels/pixelsPerMetre;
  const geometry = new THREE.PlaneBufferGeometry(planeWidth, planeHeight);

  const loadManager = new THREE.LoadingManager();
  const loader = new THREE.EXRLoader(loadManager);

  let brdfTexturePaths = new Map([
    ['diffuse', 'textures/coffee-matte/brdf-diffuse_cropf16.exr'],
    ['normals', 'textures/coffee-matte/brdf-normals_cropf16.exr'],
    ['roughness', 'textures/coffee-matte/brdf-roughness_cropf16.exr'],
    ['specular', 'textures/coffee-matte/brdf-specular_cropf16.exr'],
  ]);
  let brdfMaterials = new Map();

  for (let [name, path] of brdfTexturePaths) {
    loader.load(path,
      function (texture, textureData) {
        // Run after each texture is loaded.
        console.log('Loaded:', name, texture, textureData);

        // FIXME: Mip map filtering doesn't seem to work for EXR textures. WebGL complains: RENDER WARNING: texture
        // bound to texture unit 0 is not renderable. It maybe non-power-of-2 and have incompatible texture
        // filtering. This can possibly be overcome by loading the right extensions:
        // this.ms_Renderer.context.getExtension( 'OES_texture_float' );
        // this.ms_Renderer.context.getExtension( 'OES_texture_float_linear' );
        // or the equivalent for half-float textures.
        texture.minFilter = THREE.NearestFilter;
        texture.magFilter = THREE.NearestFilter;
        texture.name = name;
        // Flip from chart space back into camera view space.
        texture.flipY = true;
        // iOS does not support WebGL2
        // Textures need to be square powers of 2 for WebGL1
        // texture.repeat.set(matxs/padxs, matxs/padys);
        brdfMaterials.set(name, new THREE.MeshBasicMaterial({map: texture}));
      }
    );
  }

  const loadingElem = document.querySelector('#loading');
  const progressBarElem = loadingElem.querySelector('.progressbar');

  loadManager.onLoad = () => {
    // Run after all textures are loaded.
    loadingElem.style.display = 'none';
    const mesh = new THREE.Mesh(geometry, brdfMaterials.get('diffuse'));
    scene.add(mesh);
    render();
  };

  loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
    const progress = itemsLoaded / itemsTotal;
    progressBarElem.style.transform = `scaleX(${progress})`;
  };

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const pixelRatio = window.devicePixelRatio;
    const width  = canvas.clientWidth  * pixelRatio | 0;
    const height = canvas.clientHeight * pixelRatio | 0;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  let stats = new Stats();
  stats.showPanel(0); // 0: fps, 1: ms / frame, 2: MB RAM, 3+: custom
  document.body.appendChild(stats.dom);

  let renderRequested = false;

  function render() {
    renderRequested = undefined;

    stats.begin();
    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    controls.update();
    renderer.toneMappingExposure = exposureGain*state.exposure;
    renderer.render(scene, camera);
    stats.end();
  }
  render();

  function requestRenderIfNotRequested() {
    if (!renderRequested) {
      renderRequested = true;
      requestAnimationFrame(render);
    }
  }

  controls.addEventListener('change', requestRenderIfNotRequested);
  window.addEventListener('resize', requestRenderIfNotRequested);
}

if ( WEBGL.isWebGLAvailable() === false ) {
    document.body.appendChild( WEBGL.getWebGLErrorMessage() );
}

main();
</script>
</html>

