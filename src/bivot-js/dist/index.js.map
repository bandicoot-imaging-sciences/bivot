{"version":3,"file":"index.js","sources":["../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../utils/jsonLib.js","../../utils/stateUtils.js","../bivot.js","../shaders.js","../../utils/objLib.js","../index.js"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","// Given a JSON file URL, return a Promise to load the file\nexport async function loadJsonFilePromise(url) {\n  //console.log('loadJsonFilePromise: ', url);\n  var promise = new Promise((resolve, reject) => {\n    var req = new XMLHttpRequest();\n    req.open(\"GET\", url);\n    req.overrideMimeType(\"application/json\");\n    req.onload = () => {\n      if (req.status >= 200 && req.status < 300) {\n        resolve(req.response);\n      } else {\n        reject(req.statusText);\n      }\n    };\n    req.onerror = () => {\n      reject(req.statusText);\n    };\n    req.send();\n  });\n\n  return promise;\n}\n\n// Given a JSON file URL, return the file contents as an object.\n// If an exception occurs during loading or parsing, null is returned instead.\nexport async function loadJsonFile(url) {\n  var parsed;\n  try {\n    const p = await loadJsonFilePromise(url);\n    parsed = await JSON.parse(p);\n  } catch(e) {\n    parsed = null;\n  }\n  return parsed;\n}\n","import * as THREE from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/build/three.module.js';\n\n// TODO: Share this code from bivot.js instead of duplicating\n\nfunction arrayToVector(input, vecType) {\n  // If the input is an Array, convert it to the specified vector type (either THREE.Vector2,\n  // THREE.Vector3, or THREE.Color).\n  console.assert(vecType == THREE.Vector2 || vecType == THREE.Vector3 || vecType == THREE.Color);\n  var output;\n  if (Array.isArray(input)) {\n    output = new vecType();\n    output.fromArray(input);\n  } else {\n    output = input;\n  }\n  return output;\n}\n\n// Define the keys in state which are vectors, and their type\nexport function jsonToState(inDict, outDict, vectorKeys=null) {\n  if (vectorKeys == null) {\n    vectorKeys = {\n      \"lightPosition\": THREE.Vector3,\n      \"lightPositionOffset\": THREE.Vector2\n    };\n  }\n  for (var key in inDict) {\n    let t = vectorKeys[key];\n    if (t == undefined) {\n      outDict[key] = inDict[key];\n    } else {\n      outDict[key] = arrayToVector(inDict[key], t);\n    }\n  }\n}\n\nexport function stateToJson(inDict, outDict, fieldsFilter, vectorKeys) {\n  for (var i = 0; i < fieldsFilter.length; i++) {\n    let key = fieldsFilter[i]\n    let t = vectorKeys[key];\n    if (t == undefined) {\n      outDict[key] = inDict[key];\n    } else {\n      outDict[key] = Object.values(inDict[key]);\n    }\n  }\n}\n\nexport function copyStatesCloneVectors(src, dst, vectorKeys) {\n  for (var k in src) {\n    let t = vectorKeys[k];\n    if (t == undefined) {\n      dst[k] = src[k];\n    } else {\n      // Ensure vector is copied as a new object\n      dst[k] = src[k].clone();\n    }\n  }\n}\n\nexport function copyStateFields(src, dst) {\n  //console.log('copyStateFields: ', src, dst);\n  for (var k in src) {\n    if (typeof(k) == 'array') {\n      dst[k] = src[k].slice();\n    } else {\n      dst[k] = src[k];\n    }\n  }\n}\n","// Bivot material viewer\n// https://github.com/bandicoot-imaging-sciences/bivot\n// Copyright (C) Bandicoot Imaging Sciences 2019\n\n/*\nParts of this script were adapted from third party code. Refer to LICENSE.md for the\nrelevant licenses.\n\nParts adapted from Threejs:\n- EXR texture loading.\n  https://github.com/mrdoob/three.js/blob/dev/examples/webgl_loader_texture_exr.html\n- Initial shader structure including lighting.\n  https://github.com/mrdoob/three.js/blob/dev/examples/js/shaders/SkinShader.js\n  https://github.com/mrdoob/three.js/blob/dev/examples/js/shaders/TerrainShader.js\n- Tangent-space normal map calculations.\n  https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshphysical_vert.glsl.js\n  https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshphysical_frag.glsl.js\n\nParts adapted from Threejsfundamentals:\n- Responsive layout\n- On demand rendering\n- Initial HTML and JS structure\n- Texture loading progress bar.\n  https://github.com/greggman/threejsfundamentals/blob/master/threejs/threejs-render-on-demand-w-gui.html\n  https://github.com/greggman/threejsfundamentals/blob/master/threejs/threejs-textured-cube-wait-for-all-textures.html\n*/\n\n'use strict';\n\n// The Three.js import paths in bivot.js and shaers.js need to match.\n\n// Somewhere in between r116 and r117 our lighting broke.\nimport * as THREE from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/build/three.module.js';\n\nimport { OrbitControls } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/controls/OrbitControls.js';\nimport { EXRLoader } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/loaders/EXRLoader.js';\nimport { OBJLoader } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/loaders/OBJLoader.js';\nimport { WEBGL } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/WebGL.js';\nimport { EffectComposer } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/postprocessing/RenderPass.js';\nimport { ShaderPass } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/postprocessing/ShaderPass.js';\nimport { UnrealBloomPass } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/postprocessing/UnrealBloomPass.js';\nimport { AdaptiveToneMappingPass } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/postprocessing/AdaptiveToneMappingPass.js';\nimport { FXAAShader } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/shaders/FXAAShader.js';\nimport { GammaCorrectionShader } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/shaders/GammaCorrectionShader.js';\nimport { RectAreaLightUniformsLib } from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/examples/jsm/lights/RectAreaLightUniformsLib.js';\n\nimport getShaders from './shaders.js';\nimport { loadJsonFile } from '../utils/jsonLib.js';\nimport { isEmpty } from '../utils/objLib.js';\nimport { jsonToState, copyStatesCloneVectors } from '../utils/stateUtils.js';\n\n/*\n  The options object is optional and can include the following:\n    canvasID: ID for the HTML canvas element that Bivot should use for rendering\n    overlayID: ID for the HTML div element that Bivot should use for the progress bar and status text\n    configPath: relative or absolute URL for the JSON configuration file\n    renderPath: relative or absolute URL for the JSON render file\n    texturePath: relative or absolute URL for the folder containing the texture folders\n*/\nclass bivotJs {\n\n  constructor(options) {\n    this.controlModes = {\n      FULL: 'full',\n      QA: 'qa',\n      MANAGE: 'manage',\n      NONE: 'none',\n    }\n\n    const { uniforms, vertexShader, fragmentShader } = getShaders();\n    this.uniforms = uniforms;\n    this.vertexShader = vertexShader;\n    this.fragmentShader = fragmentShader;\n\n\n    let defaultOptions = {\n      canvasID: 'bivot-canvas',\n      overlayID: 'bivot-overlay',\n      configPath: 'bivot-config.json',\n      renderPath: 'bivot-renders.json',\n      texturePath: 'textures',\n      config: null,\n      material: null,\n      textures: null,\n      materialSet: null,\n      controlMode: this.controlModes.FULL,\n      useTouch: null,\n      width: 0,\n      height: 0,\n      state: null,\n      stateLoadCallback: null,\n      setZoomCallback: null,\n    }\n    this.opts = {...defaultOptions, ...options};\n\n    // Initial state and configuration.  This will likely get overridden by the config file,\n    // but if the config can't be loaded, then these are the defaults. Attributes with underscore prefixes are\n    // intended for internal use only, and should not be set in the configuration files.\n    this.state = {\n      exposure: 1.0,\n      brightness: 0.5,\n      contrast: 0.5,\n      focalLength: 85,\n      diffuse: 1.0,\n      specular: 1.0,\n      roughness: 1.0,\n      tint: true,\n      fresnel: false,\n      ambient: 1.0,\n      fxaa: true,\n      bloom: 0.1,\n      adaptiveToneMap: false,\n      toneMapDarkness: 0.04,\n      threeJsShader: true,\n      lightType: 'point',\n      areaLightWidth: 5.0,\n      areaLightHeight: 0.2,\n      // Control modes are set using lightMotion:\n      // mouse - control using mouse position and mouse buttons (auto-rotate when outside canvas)\n      // gyro - control using device tilt (auto rotate always off)\n      // animate - automated control (auto rotate always on)\n      lightMotion: 'mouse',\n      lightColor: [255, 255, 255],\n      lightPosition: new THREE.Vector3(0, 0, 1),\n      // Offset light controls by this vector. In screen co-ords: x-axis points right and y-axis points up.\n      lightPositionOffset: new THREE.Vector2(0, 0),\n      lightNumber: 1,\n      lightSpacing: 0.5,\n      light45: false,\n      scan: 'kimono 2k',\n      brdfModel: 1,\n      brdfVersion: 2,\n      yFlip: true,\n      background: 0x05, // Legacy grayscale background\n      backgroundColor: '#050505', // RGB background colour string\n      meshRotateZDegrees: 0,\n      camTiltWithMousePos: 0.0,  // Factor to tilt camera based on mouse position (-0.1 is good)\n      camTiltWithDeviceOrient: 0.0,  // Factor to tilt camera based on device orientation (0.6 is good)\n      camTiltLimitDegrees: 0.0, // Lowest elevation angle (in degrees) that the camera can tilt to.\n      lightTiltWithMousePos: 1.0,  // Factor to tilt light based on mouse position\n      lightTiltWithDeviceOrient: 1.0,  // Factor to tilt light based on device orientation\n      lightTiltLimitDegrees: 0.0, // Lowest elevation angle (in degrees) that the light can tilt to.\n      // Speed of device baseline drift towards current tilt, when current tilt elevation is lower than\n      // camTiltLimitDegrees or lightTiltLimitDegrees.\n      tiltDriftSpeed: 1.0,\n      tiltZeroOnMouseOut: false, // If true, reset the tilt to zero when the mouse moves out of the window.\n      portrait: false,\n      autoRotatePeriodMs: 0,\n      autoRotateFps: 30,\n      autoRotateCamFactor: 0.5,\n      autoRotateLightFactor: 0.9,\n      // zoom: [0.4, 0.9, 2.0],  // No default, to allow legacy galleries to keep working\n      _camPositionOffset: new THREE.Vector2(0, 0),\n      _meshRotateZDegreesPrevious: 0,\n      _statusText: '',\n    };\n\n    this.config = {\n      textureFormat: 'EXR', // Valid formats are 'JPG', 'PNG', 'EXR'.\n      loadExr: undefined, // Deprecated, use textureFormat instead.\n      loadPng: undefined, // Deprecated, use textureFormat instead.\n      loadJpeg: undefined, // Deprecated, use textureFormat instead.\n      dual8Bit: false, // Make 16-bit texture from two 8-bit PNG images. Only valid when textureFormat == 'PNG'.\n      showInterface: true,\n      mouseCamControlsZoom: true,\n      mouseCamControlsRotate: true,\n      mouseCamControlsPan: true,\n      // Enables touch control for phones and tablet, but disables scrolling the page for touch-drags inside the\n      // Bivot canvas.\n      useTouch: true,\n      initCamZ: 0.9,\n      minCamZ: 0.4, // Initial value, state is changed via controls object.\n      maxCamZ: 2.0, // Initial value, state is changed via controls object.\n      linearFilter: true, // Applied during texture loading.\n      initialState: {},\n    };\n\n    if (this.opts.state) {\n      // Merge in to state only the keys provided in the options; use defaults for others\n      for (var k in this.state) {\n        if (!this.opts.state.hasOwnProperty(k)) {\n          this.opts.state[k] = this.state[k];\n        }\n      }\n\n      // Use the passed-in state as the live state object\n      this.state = this.opts.state;\n    }\n\n    // Define the keys in state which are vectors, and their type\n    this.vectorKeys = {\n      \"lightPosition\": THREE.Vector3,\n      \"lightPositionOffset\": THREE.Vector2\n    };\n\n    // Store initial state in the config\n    copyStatesCloneVectors(this.state, this.config.initialState, this.vectorKeys);\n\n    this.canvas = document.getElementById(this.opts.canvasID);\n    this.overlay = document.getElementById(this.opts.overlayID);\n    console.assert(this.canvas != null, 'canvas element ID not found:', this.opts.canvasID);\n    console.assert(this.overlay != null, 'overlay div element ID not found:', this.opts.overlayID);\n\n    this.scans = {};\n    this.materials = {};\n    this.exposureGain = 1/10000; // Texture intensities in camera count scale (e.g. 14 bit).\n    this.renderRequested = false;\n    this.scene = new THREE.Scene();\n    this.camera = null;\n    this.lights = null;\n    this.lights45 = null;\n    this.mesh = null;\n    this.renderer = null;\n    this.fxaaPass = null;\n    this.toneMappingPass = null;\n    this.renderPass = null;\n    this.bloomPass = null;\n    this.gammaCorrectPass = null;\n    this.composer = null;\n    this.controls = null;\n    // Start false so that auto-rotate is always active until the mouse moves, even if the mouse starts over\n    // the canvas.\n    this.mouseInCanvas = false;\n\n    // Tracking to handle cleanup\n    this.shuttingDown = false;\n    this.timeouts = [];\n    this.listeners = [];\n    this.elements = [];\n  }\n\n  startRender() {\n    let _self = this;\n\n    let fov = null;\n    let ambientLight = null;\n    let gyroDetected = false;\n    let touchDetected = detectTouch();\n    let baselineTilt = new THREE.Vector2(0, 0);\n    let baselineTiltSet = false;\n    let loader = null;\n    let firstRenderLoaded = false;\n    let brdfTextures = null;\n\n    let loadingElem = null;\n    let progressBarElem = null;\n    let subtitleElem = null;\n    let subtitleTextElem = null;\n\n    // Device orientation events require user permission for iOS > 13.\n    // We use a feature detector for tilt permission in case Android picks up the same API.\n    let orientPermNeeded = (typeof DeviceOrientationEvent !== 'undefined'\n                        && typeof DeviceOrientationEvent.requestPermission === 'function');\n    // Do we actually want to use the device orientation for anything?\n    // We set this later after loading the config.\n    let orientPermWanted = null;\n    let orientPermObtained = false;\n\n    // Device orientation events are blocked by default on iOS 12.2 - 12.4.\n    // The user can unblock them in Settings.\n    let iOSVersion = null;\n    let iOSVersionOrientBlocked = false;\n    let iOSVersionTimeoutID = null;\n    const iOSDetected = /iPhone|iPad|iPod/i.test(navigator.userAgent);\n    if (iOSDetected) {\n      iOSVersion = navigator.userAgent.match(/OS [\\d_]+/i)[0].substr(3).split('_').map(n => parseInt(n));\n      iOSVersionOrientBlocked = (iOSVersion[0] == 12 && iOSVersion[1] >= 2);\n    }\n\n    let urlFlags = getUrlFlags(); // Get options from URL\n\n    if (Object.values(this.controlModes).indexOf(urlFlags.controls) > -1) {\n      this.opts.controlMode = urlFlags.controls;\n    }\n\n    initConfig().then(() => {\n      // After loading (or failing to load) the config, begin the initialisation sequence.\n      processUrlFlags();\n\n      // Backward compatibility for deprecated load* flags.\n      console.assert(((this.config.loadExr || 0) + (this.config.loadPng || 0) + (this.config.loadJpeg || 0)) <= 1);\n      if (this.config.loadExr) {\n        this.config.textureFormat = 'EXR';\n      } else if (this.config.loadPng) {\n        this.config.textureFormat = 'PNG';\n      } else if (this.config.loadJpeg) {\n        this.config.textureFormat = 'JPG';\n      }\n      if (this.config.hasOwnProperty('textureFormat') && typeof this.config.textureFormat === 'string') {\n        this.config.textureFormat = this.config.textureFormat.toUpperCase();\n      }\n\n      console.log('Options:', this.opts);\n      console.log('Config:', this.config);\n      console.log('State:', this.state);\n      console.log('Renders:', this.scans)\n\n      orientPermWanted = (this.state.camTiltWithDeviceOrient != 0.0 || this.state.lightTiltWithDeviceOrient != 0.0);\n\n      initialiseOverlays(this.overlay);\n      initialiseLighting(this.getBgColorFromState(this.state), this.scene);\n      this.camera = initialiseCamera(this.state.focalLength, this.config.initCamZ);\n      this.controls = initialiseControls(this.camera, this.canvas, this.config, this.state.camTiltLimitDegrees);\n      // if (this.config.showInterface) {\n        //   addControlPanel();\n        // }\n      this.initialiseCanvas(this.canvas, this.opts.width, this.opts.height);\n      this.renderer = this.initialiseRenderer();\n      RectAreaLightUniformsLib.init(this.renderer); // Initialise LTC look-up tables for area lighting\n      this.composer = this.initialiseComposer(this.renderer, updateToneMapParams);\n      this.updateCanvas();\n\n      loadScan();\n\n      initialiseZoom(this.state.zoom);\n\n      // Add listeners after finishing config and initialisation\n      if (orientPermWanted) {\n        this.registerEventListener(window, 'deviceorientation', detectGyro, false);\n      }\n      this.registerEventListener(window, 'resize', this.requestRender);\n\n      if (this.opts.useTouch == true || this.opts.useTouch == false) {\n        this.config.useTouch = this.opts.useTouch;\n      }\n    });\n    // ========== End mainline; functions follow ==========\n\n    async function initConfig() {\n      if (_self.opts.materialSet) {\n        _self.scans = await loadMaterialSet(_self.opts.materialSet);\n      }\n      if (!_self.scans || isEmpty(_self.scans)) {\n        // materials not provided or failed to load\n        await loadConfig(_self.opts.configPath, _self.config, _self.state, _self.opts.config, _self.vectorKeys)\n        _self.scans = await loadRender(_self.opts.renderPath, _self.opts.material);\n      }\n      if (!_self.scans.hasOwnProperty(_self.state.scan)) {\n        // If the scan state isn't a scan in the list, use the first scan in the list\n        _self.state.scan = Object.keys(_self.scans)[0];\n      }\n    }\n\n    function onLoad() {\n      // Run after all textures and the mesh are loaded.\n      loadingElem.style.display = 'none';\n      _self.uniforms.diffuseMap.value = brdfTextures.get('diffuse');\n      _self.uniforms.normalMap.value = brdfTextures.get('normals');\n      _self.uniforms.specularMap.value = brdfTextures.get('specular');\n      if (_self.config.dual8Bit) {\n        _self.uniforms.diffuseMapLow.value = brdfTextures.get('diffuse_low');\n        _self.uniforms.normalMapLow.value = brdfTextures.get('normals_low');\n        _self.uniforms.specularMapLow.value = brdfTextures.get('specular_low');\n      }\n\n      // Set up the material and attach it to the mesh\n      let material = new THREE.ShaderMaterial(\n        {\n          fragmentShader: _self.fragmentShader,\n          vertexShader: _self.vertexShader,\n          uniforms: _self.uniforms,\n          lights: true\n        }\n      );\n      material.defines = {\n        USE_NORMALMAP: 1,\n        OBJECTSPACE_NORMALMAP: 1,\n        // USE_TANGENT: 1,\n      };\n      material.extensions.derivatives = true;\n      _self.mesh.traverse(function(child) {\n        if (child instanceof THREE.Mesh) {\n          child.material = material;\n        }\n      });\n      _self.scene.add(_self.mesh);\n\n      // The deviceorientation event has been restricted for privacy reasons.\n      // A work around on iOS >= 12.2 is for the user to enable it in iOS Settings > Safari (off by default).\n      // The web page also has to be served over https.\n      // iOS 13 introduced a permissions API so that we can ask the user more directly. The request has to be in\n      // response to a \"user gesture\", e.g. in response to the user tapping on the canvas.\n      if (orientPermWanted && !firstRenderLoaded && (iOSVersionOrientBlocked || orientPermNeeded) && !gyroDetected) {\n        setTiltWarning();\n      }\n      firstRenderLoaded = true;\n      baselineTiltSet = false;\n\n      _self.updateLightingGrid();\n      _self.requestRender();\n    };\n\n    function mergeDictKeys(keys, out, first, second, third, vectorKeys) {\n      keys.forEach(function(item, index) {\n        let t = vectorKeys[item];\n        if (item in first) {\n          if (t == undefined) {\n            out[item] = first[item];\n          } else {\n            out[item].copy(first[item]);\n          }\n        } else if (item in second) {\n          if (t == undefined) {\n            out[item] = second[item];\n          } else {\n            out[item].copy(second[item]);\n          }\n        } else if (item in third) {\n          if (t == undefined) {\n            out[item] = third[item];\n          } else {\n            out[item].copy(third[item]);\n          }\n        }\n      });\n    }\n\n    async function loadMaterialSet(filename) {\n      console.log('loadMaterialSet(): Loading material set file:', filename);\n      const materialSet = {};\n      if (filename) {\n        const jsonMaterialSet = await loadJsonFile(filename);\n        if (jsonMaterialSet) {\n          const numMaterials = jsonMaterialSet.materials.length;\n          for (var i = 0; i < numMaterials; i++) {\n            const galleryMats = jsonMaterialSet.materials[i].gallery;\n            const galleryMat = galleryMats[galleryMats.length - 1];\n            const render = galleryMat.config.renders[galleryMat.name];\n            var bivotMat = {};\n            for (var key in galleryMat) {\n              if (key != 'config' && galleryMat.hasOwnProperty(key)) {\n                bivotMat[key] = galleryMat[key];\n              }\n            }\n            bivotMat['config'] = {\n              renders: {\n                [galleryMat.name]: {\n                  state: {}\n                }\n              }\n            };\n            const bivotMatRender = bivotMat.config.renders[galleryMat.name];\n            for (var key in render) {\n              if (key != 'state' && render.hasOwnProperty(key)) {\n                bivotMatRender[key] = render[key];\n              }\n            }\n            jsonToState(render['state'], bivotMatRender['state']);\n            materialSet[bivotMat.name] = bivotMat;\n          }\n        }\n      }\n      console.log('materialSet loaded: ', materialSet);\n      return materialSet;\n    }\n\n    async function loadConfig(configFilename, config, state, optsConfig, vectorKeys) {\n      if (configFilename) {\n        const jsonConfig = await loadJsonFile(configFilename);\n        if (jsonConfig) {\n          console.log('Loaded:', configFilename);\n\n          // Merge items from the JSON config file into the initial state\n          for (var k in jsonConfig) {\n            if (k == 'initialState') {\n              jsonToState(jsonConfig[k], config.initialState, vectorKeys);\n            } else {\n              config[k] = jsonConfig[k];\n            }\n          }\n\n          // Copy initial state from JSON into the live state\n          copyStatesCloneVectors(config.initialState, state, vectorKeys);\n        } else {\n          console.log('Error: Failed to load ' + configFilename);\n        }\n      } else if (optsConfig) {\n        console.log('Using provided config object');\n        for (var k in optsConfig) {\n          if (k == 'initialState') {\n            jsonToState(optsConfig[k], config.initialState, vectorKeys);\n          } else {\n            config[k] = optsConfig[k];\n          }\n        }\n      }\n    }\n\n    async function loadRender(renderFilename, material) {\n      var scans = {};\n      if (renderFilename) {\n        const jsonRender = await loadJsonFile(renderFilename);\n        if (jsonRender) {\n          console.log(`Loaded ${renderFilename}:`, jsonRender);\n          if (urlFlags.showcase == 1) {\n            for (let r in jsonRender.renders) {\n              if (jsonRender.renders.hasOwnProperty(r)) {\n                if (jsonRender.renders[r].showcase > 0) {\n                  scans[r] = jsonRender.renders[r];\n                }\n              }\n            }\n          } else {\n            scans = jsonRender.renders;\n          }\n        } else {\n          console.log('Error: Failed to load ' + renderFilename);\n        }\n      } else if (material) {\n        console.log('Using provided material object');\n        scans = material.config.renders;\n        // TODO: Apply showcase flag to this branch\n      }\n      return scans;\n    }\n\n    function getJSON(url, callback) {\n      var req = new XMLHttpRequest();\n      req.open(\"GET\", url);\n      req.overrideMimeType(\"application/json\");\n      req.onload = function() {\n        var status = req.status;\n        if (status == 200) {\n          callback(null, req.response);\n        } else {\n          callback(status, req.response);\n        }\n      };\n      req.onerror = function() {\n        callback(req.status, req.response);\n      };\n      req.send();\n    };\n\n    function getUrlFlags() {\n      const validFlags = {\n        controls: ['full', 'qa', 'manage', 'none'],\n        show: 'SAFE_STRING',\n        showcase: ['1'],\n        textureFormat: ['JPG', 'PNG', 'EXR']\n      };\n\n      const parsedUrl = new URL(window.location.href);\n      let dict = {};\n\n      for (const [key, value] of parsedUrl.searchParams) {\n        const decodeValue = decodeURI(value)\n        if (validFlags.hasOwnProperty(key)) {\n          const validValues = validFlags[key];\n          if (Array.isArray(validValues)) {\n            if (validValues.includes(decodeValue)) {\n              dict[key] = decodeValue;\n            } else {\n              console.warn('Invalid query parameter value for key:', key);\n            }\n          } else if (validValues == 'SAFE_STRING') {\n            const re = /^[a-zA-Z0-9-_\\s]*$/;\n            if (re.test(decodeValue)) {\n              dict[key] = decodeValue;\n            } else {\n              console.warn('Invalid characters in string value for key:', key);\n            }\n          }\n        } else {\n          console.warn('Invalid keys found in query parameters');\n        }\n      }\n\n      console.log('URL flags:', dict);\n      return dict;\n    }\n\n    function processUrlFlags() {\n      if (urlFlags.hasOwnProperty('show')) {\n        _self.state.scan = urlFlags.show;\n      }\n      if (urlFlags.hasOwnProperty('textureFormat')) {\n        _self.config.textureFormat = urlFlags.textureFormat;\n      }\n    }\n\n    function initialiseOverlays(overlay) {\n      let loadingDiv = _self.registerElement(document, 'div');\n      loadingDiv.className += 'bivot-loading';\n      let progressDiv = _self.registerElement(document, 'div');\n      progressDiv.className += 'bivot-progress';\n      let progressBarDiv = _self.registerElement(document, 'div');\n      progressBarDiv.className += 'bivot-progressbar';\n      overlay.appendChild(loadingDiv);\n      loadingDiv.appendChild(progressDiv);\n      progressDiv.appendChild(progressBarDiv);\n\n      let subtitleDiv = _self.registerElement(document, 'div');\n      subtitleDiv.className += 'bivot-subtitle';\n      let subtitleBGDiv = _self.registerElement(document, 'div');\n      subtitleBGDiv.className += 'bivot-subtitle-background';\n      let subtitleTextP = _self.registerElement(document, 'p');\n      subtitleTextP.className += 'bivot-subtitle-text';\n      overlay.appendChild(subtitleDiv);\n      subtitleDiv.appendChild(subtitleBGDiv);\n      subtitleBGDiv.appendChild(subtitleTextP);\n\n      loadingElem = loadingDiv;\n      progressBarElem = progressBarDiv;\n      subtitleElem = subtitleDiv;\n      subtitleTextElem = subtitleTextP;\n    }\n\n    function updateToneMapParams() {\n      if (!_self.state.adaptiveToneMap) {\n        _self.toneMappingPass.setAdaptive(false);\n        _self.toneMappingPass.setAverageLuminance(_self.state.toneMapDarkness);\n      }\n    }\n\n    function initialiseLighting(background, scene) {\n      scene.background = new THREE.Color(background);\n\n      _self.updateLightingGrid();\n      updateLightMotion();\n\n      const ambientColour = 0x3F3F3F;\n      const ambientIntensity = 1.0;\n      ambientLight = new THREE.AmbientLight(ambientColour, ambientIntensity);\n      scene.add(ambientLight);\n    }\n\n    function initialiseCamera(focalLength, initZ) {\n      // Physical distance units are in metres.\n      const sensorHeight = 0.024;\n      fov = fieldOfView(focalLength, sensorHeight);\n      const aspect = 2;  // the canvas default\n      const near = 0.01;\n      const far = 10;\n      var camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n      camera.position.set(0, 0, initZ);\n      return camera;\n    }\n\n    function initialiseZoom(zoomArray) {\n      if (zoomArray) {\n        _self.state.currentZoom = zoomArray[1];\n        _self.updateZoom();\n      }\n    }\n\n    function controlsChange(event) {\n      if (_self.opts.setZoomCallback) {\n        _self.opts.setZoomCallback(_self.camera.position.length());\n      }\n      _self.requestRender();\n    }\n\n    function initialiseControls(camera, canvas, config, tiltLimit) {\n      var controls = new OrbitControls(camera, canvas);\n      controls.enableDamping = true;\n      controls.dampingFactor = 0.15;\n      controls.panSpeed = 0.3;\n      controls.rotateSpeed = 1.0;\n      controls.zoomSpeed = 1.0;\n      controls.target.set(0, 0, 0);\n      controls.update();\n      controls.enableZoom = config.mouseCamControlsZoom;\n      controls.enableRotate = config.mouseCamControlsRotate;\n      controls.enablePan = config.mouseCamControlsPan;\n      controls.minDistance = config.minCamZ;\n      controls.maxDistance = config.maxCamZ;\n      controls.screenSpacePanning = true;\n      if (touchDetected) {\n        controls.zoomSpeed *= 0.25;\n        if (!config.useTouch) {\n          controls.dispose();\n        }\n      }\n      updateCamTiltLimit(controls, tiltLimit);\n      _self.registerEventListener(controls, 'change', controlsChange);\n      return controls;\n    }\n\n    function updateCamTiltLimit(controls, limitDeg) {\n      let tiltLimitRadians = Math.PI * limitDeg / 180;\n      controls.minPolarAngle = tiltLimitRadians;\n      controls.maxPolarAngle = Math.PI - tiltLimitRadians;\n      controls.minAzimuthAngle = -Math.PI/2 + tiltLimitRadians;\n      controls.maxAzimuthAngle = +Math.PI/2 - tiltLimitRadians;\n    }\n\n    function detectGyro(event) {\n      if (event.alpha || event.beta || event.gamma) {\n        gyroDetected = true;\n        window.removeEventListener('deviceorientation', detectGyro, false);\n\n        _self.state.lightMotion = 'gyro';\n        updateLightMotion();\n      }\n    }\n\n    function detectTouch() {\n      // Detect if primary control is touch (true for phones and tablets, false for touch-screen laptops with\n      // trackpad and mouse).\n      return window.matchMedia(\"(pointer: coarse)\").matches;\n    }\n\n    function requestTiltPermission(event) {\n      if (typeof DeviceOrientationEvent.requestPermission === 'function') {\n        DeviceOrientationEvent.requestPermission()\n          .then(permissionState => {\n            if (permissionState === 'granted') {\n              orientPermObtained = true;\n              updateLightMotion();\n              clearTiltWarning();\n            }\n          })\n          .catch(console.error);\n      }\n    }\n\n    function setTiltWarning() {\n      iOSVersionTimeoutID = setTimeout(() => {\n        if (iOSVersionOrientBlocked) {\n          _self.state._statusText = 'To enable tilt control, please switch on Settings > Safari > Motion & Orientation Access and then reload this page.';\n        }\n        updateStatusTextDisplay();\n      }, 1000);\n      _self.timeouts.push(iOSVersionTimeoutID);\n      _self.registerEventListener(window, 'deviceorientation', clearTiltWarning);\n    }\n\n    function clearTiltWarning() {\n      clearTimeout(iOSVersionTimeoutID);\n      window.removeEventListener('deviceorientation', clearTiltWarning);\n      _self.state._statusText = '';\n      // Permission may have been granted in another window running Bivot, e.g. another IFRAME. If so, we should\n      // have started to receive valid deviceorientation events, and gyroDetected will be true. This only works\n      // if detectGyro() was added as a deviceorientation event listener *before* clearTiltWarning().\n      if (gyroDetected) {\n        orientPermObtained = true;\n      }\n      updateStatusTextDisplay();\n    }\n\n    function updateStatusTextDisplay() {\n      // Trying to add this button while also displaying status text sends iOS Safari into a reload loop. So the\n      // button takes precedence.\n      if (orientPermWanted && orientPermNeeded && !orientPermObtained) {\n        subtitleElem.style.display = 'flex';\n        let requestButton = _self.registerElement(document, 'button');\n        requestButton.className = 'bivot-button';\n        requestButton.innerHTML = 'Tap to enable tilt control';\n        requestButton.onclick = requestTiltPermission;\n        subtitleTextElem.appendChild(requestButton);\n      } else if (_self.state._statusText.length == 0) {\n        subtitleElem.style.display = 'none';\n        subtitleTextElem.innerHTML = '';\n      } else {\n        subtitleElem.style.display = 'flex';\n        subtitleTextElem.innerHTML = _self.state._statusText;\n      }\n    }\n\n    function updateLightMotion() {\n      if (_self.state.lightMotion == 'mouse') {\n        window.removeEventListener('deviceorientation', onDeviceOrientation, false);\n        _self.registerEventListener(document, 'mousemove', onDocumentMouseMove, false);\n        _self.registerEventListener(document, 'mouseout', onDocumentMouseOut, false);\n        _self.registerEventListener(_self.canvas, 'mouseover', onCanvasMouseOver, false);\n        _self.registerEventListener(_self.canvas, 'mouseout', onCanvasMouseOut, false);\n      } else if (_self.state.lightMotion == 'gyro') {\n        _self.registerEventListener(window, 'deviceorientation', onDeviceOrientation, false);\n        document.removeEventListener('mousemove', onDocumentMouseMove, false);\n        document.removeEventListener('mouseout', onDocumentMouseOut, false);\n        _self.canvas.removeEventListener('mouseover', onCanvasMouseOver, false);\n        _self.canvas.removeEventListener('mouseout', onCanvasMouseOut, false);\n      } else {\n        console.assert(_self.state.lightMotion == 'animate');\n        window.removeEventListener('deviceorientation', onDeviceOrientation, false);\n        document.removeEventListener('mousemove', onDocumentMouseMove, false);\n        document.removeEventListener('mouseout', onDocumentMouseOut, false);\n        _self.canvas.removeEventListener('mouseover', onCanvasMouseOver, false);\n        _self.canvas.removeEventListener('mouseout', onCanvasMouseOut, false);        \n      }\n    }\n\n    function onDocumentMouseMove(event) {\n      // Update cams and lights using relative mouse co-ords between -1 and 1 within the canvas\n      event.preventDefault();\n      const viewPortX = event.clientX;\n      const viewPortY = event.clientY;\n      if (_self.isViewPortCoordInCanvas(viewPortX, viewPortY)) {\n        const rect = _self.canvas.getBoundingClientRect();\n        const xy = new THREE.Vector2(\n          ((viewPortX - rect.left) / (rect.right - rect.left)) * 2 - 1,\n          -((viewPortY - rect.top) / (rect.bottom - rect.top)) * 2 + 1\n        );\n        _self.updateCamsAndLightsFromXY(xy, _self.state.lightTiltWithMousePos, _self.state.camTiltWithMousePos);\n      }\n    }\n\n    function onDocumentMouseOut(event) {\n      // Reset light position and camera tilt if the mouse moves out.\n      if (_self.lights && _self.state.tiltZeroOnMouseOut) {\n        _self.state.lightPosition.set(_self.state.lightPositionOffset.x, _self.state.lightPositionOffset.y, 1);\n        _self.state.lightPosition.copy(\n          _self.xyTo3dDirection(new THREE.Vector2(0, 0), _self.state.lightPositionOffset, _self.state.lightTiltWithMousePos,\n          _self.state.lightTiltLimitDegrees)\n          );\n\n        _self.updateLightingGrid();\n      }\n\n      if (_self.camera && _self.state.tiltZeroOnMouseOut && _self.state.camTiltWithMousePos != 0.0) {\n        _self.camera.position.set(0, 0, _self.camera.position.length());\n      }\n\n      if (_self.state.autoRotatePeriodMs \n        && (_self.state.lightMotion == 'mouse' || _self.state.lightMotion == 'animate')) {\n        _self.requestRender();\n      }\n    }\n\n    function onCanvasMouseOver(event) {\n      _self.mouseInCanvas = true;\n    }\n\n    function onCanvasMouseOut(event) {\n      _self.mouseInCanvas = false;\n    }\n\n    function getOrientation(event) {\n      // Update lights and camera using the device tilt rotation\n      let orient = window.orientation || 0;\n      let rotation = new THREE.Vector2();\n      if (orient == 0 || orient == 180) {\n        // Portrait\n        rotation.set(event.beta, event.gamma);\n      } else {\n        // Landscape\n        rotation.set(event.gamma, event.beta);\n      }\n      if (orient == 0) {\n        rotation.y = -rotation.y;\n      } else if (orient == 90) {\n        rotation.x = -rotation.x;\n        rotation.y = -rotation.y;\n      } else if (orient == 180) {\n        rotation.x = -rotation.x;\n      }\n\n      return rotation;\n    }\n\n    function onDeviceOrientation(event) {\n      const currentTilt = getOrientation(event);\n      if (!baselineTiltSet) {\n        baselineTilt.copy(currentTilt);\n        baselineTiltSet = true;\n      }\n      const deltaTilt = currentTilt.clone().sub(baselineTilt);\n      const xy = new THREE.Vector2(\n        Math.sin(THREE.Math.degToRad(deltaTilt.y)),\n        Math.sin(THREE.Math.degToRad(deltaTilt.x))\n      );\n      const elevationLimit = Math.max(_self.state.camTiltLimitDegrees, _self.state.lightTiltLimitDegrees);\n      const qLimit = Math.cos(THREE.Math.degToRad(elevationLimit));\n      if (xy.length() > qLimit) {\n        const surplus = xy.length() - xy.clone().clampLength(0.0, qLimit).length();\n        baselineTilt.addScaledVector(deltaTilt, surplus * _self.state.tiltDriftSpeed);\n      }\n      _self.updateCamsAndLightsFromXY(xy, _self.state.lightTiltWithDeviceOrient, _self.state.camTiltWithDeviceOrient);\n    }\n\n    function newMeshRotation() {\n      _self.state._meshRotateZDegreesPrevious = 0;\n      _self.updateMeshRotation();\n    }\n\n    function loadScansImpl(brdfTexturePaths, meshPath, loadManager) {\n      var objLoader = new OBJLoader(loadManager);\n      objLoader.load(meshPath,\n        function(object) {\n          console.log('Loaded mesh object:', meshPath);\n          _self.mesh = object;\n          _self.mesh.traverse(function(child) {\n            if (child instanceof THREE.Mesh) {\n              child.geometry.computeVertexNormals();\n            }\n          });\n          newMeshRotation();\n        },\n        function (xhr) {},\n        function (error) {\n          console.log('Mesh unavailable; using planar geometry');\n          _self.mesh = new THREE.Mesh(getPlaneGeometry());\n          newMeshRotation();\n        }\n      );\n\n      brdfTextures = new Map();\n\n      // If a materialSet was provided, set the texture format directly from the texture file extensions\n      if (_self.opts.materialSet) {\n        for (var [key, value] of brdfTexturePaths) {\n          _self.config.textureFormat = value.path.split('.').pop().toUpperCase();\n          break;\n        }\n      }\n\n      if (_self.config.textureFormat == 'EXR') {\n        loader = new EXRLoader(loadManager);\n      } else{\n        loader = new THREE.TextureLoader(loadManager);\n      }\n      onProgress('', 0, 1);\n\n      // In theory, the extension OES_texture_float_linear should enable mip-mapping for floating point textures.\n      // However, even though these extensions load OK, when I set texture.magFilter to LinearMipMapLinearFilter I\n      // get a blank texture and WebGL console errors complaining that the texture is not renderable. Tested on\n      // Chrome for Windows and Safari for iOS 12.3.1.\n\n      /*\n      if (! this.renderer.extensions.get('OES_texture_float')) {\n        alert('OES_texture_float not supported');\n        throw 'missing webgl extension';\n      }\n\n      if (! this.renderer.extensions.get('OES_texture_float_linear')) {\n        alert('OES_texture_float_linear not supported');\n        throw 'missing webgl extension';\n      }\n      */\n      console.log(brdfTexturePaths)\n      for (let [key, value] of brdfTexturePaths) {\n        loader.load(value.path,\n          function (texture, textureData) {\n            // Run after each texture is loaded.\n\n            // Both LinearFilter and NearestFilter work on Chrome for Windows and Safari for iOS 12.3.1. In\n            // principle, for most surfaces, LinearFilter should reduce shimmer caused by anti-aliasing.\n            // However, for some surfaces with high-frequency normals or specular detials, LinearFilter causes\n            // cause moire artifacts, so NearestFilter is used.\n            if (_self.config.linearFilter) {\n              if (_self.config.textureFormat == 'EXR') {\n                // FIXME: Setting magFilter to LinearMipMapLinearFilter doesn't seem to work for float EXR textures.\n                // WebGL complains: RENDER WARNING: texture bound to texture unit 0 is not renderable. It maybe\n                // non-power-of-2 and have incompatible texture filtering. This can possibly be overcome by loading\n                // the right extensions:\n                // OES_texture_float\n                // OES_texture_float_linear\n                // or the equivalent for half-float textures. However, when I tried this I got a blank render and\n                // console errors (see notes on extension loading above).\n                texture.minFilter = THREE.LinearFilter;\n                texture.magFilter = THREE.LinearFilter;\n              } else {\n                texture.minFilter = THREE.LinearMipMapLinearFilter;\n                texture.magFilter = THREE.LinearFilter;\n              }\n            } else {\n              texture.minFilter = THREE.NearestFilter;\n              texture.magFilter = THREE.NearestFilter;\n            }\n\n            texture.name = key;\n            // Flip from chart space back into camera view space.  The handling of texture.flipY inside Three.js\n            // is reversed for PNG compared with EXR.\n            texture.flipY = (_self.state.yFlip == (_self.config.textureFormat == 'EXR'));\n            // EXRLoader sets the format incorrectly for single channel textures.\n            texture.format = value.format;\n            // iOS does not support WebGL2\n            // Textures need to be square powers of 2 for WebGL1\n            // texture.repeat.set(matxs/padxs, matxs/padys);\n            console.log('Loaded:', key, value.path);\n            brdfTextures.set(key, texture);\n          }\n        );\n      }\n    }\n\n    function loadScan() {\n      if (_self.mesh != null) {\n        _self.scene.remove(_self.mesh); // Remove old mesh from scene and clean up memory\n        _self.mesh.traverse(function(child) {\n          if (child instanceof THREE.Mesh) {\n            child.geometry.dispose();\n            child.material.dispose();\n          }\n        });\n      }\n\n      const loadManager = new THREE.LoadingManager();\n      loadManager.onLoad = onLoad;\n      loadManager.onProgress = onProgress;\n\n      // List of keys to merge between the 3 states.\n      const keys = Object.keys(_self.config.initialState);\n      keys.push('zoom'); // Necessary because zoom is omitted from initialState to support legacy galleries\n      if (_self.opts.materialSet) {\n        const material = _self.scans[_self.state.scan];\n        loadScanFromMaterial(loadManager, material, keys);\n      } else if (_self.opts.textures && _self.opts.material) {\n        loadScanFromTextures(loadManager, _self.opts.textures, _self.opts.material, keys);\n      } else {\n        const tex_dir = _self.opts.texturePath + '/' + _self.state.scan;\n        loadScanMetadata(loadManager, tex_dir, keys);\n      }\n    }\n\n    function loadScanFromMaterial(loadManager, material, keys) {\n      const textures = {};\n      for (var key in material.textures) {\n        textures[key] = `${material.location}/${material.textures[key]}`;\n      }\n      return loadScanFromTextures(loadManager, textures, material, keys);\n    }\n\n    function loadScanFromTextures(loadManager, textures, material, keys) {\n      let paths = new Map();\n      paths.set('diffuse', {path: textures.basecolor, format: THREE.RGBFormat});\n      paths.set('normals', {path: textures.normals, format: THREE.RGBFormat});\n      paths.set('specular', {path: textures.specular, format: THREE.RGBFormat});\n\n      let scanState = [];\n      const metadata = material.config.renders[_self.state.scan];\n      if (metadata.hasOwnProperty('state')) {\n        jsonToState(metadata.state, scanState, _self.vectorKeys);\n      }\n      if (metadata.hasOwnProperty('version')) {\n        scanState.brdfVersion = metadata.version;\n      }\n      mergeMetadata(scanState, keys);\n      loadScansImpl(paths, textures.mesh, loadManager);\n    }\n\n    function loadScanMetadata(loadManager, texturePath, keys) {\n      const jsonFilename = texturePath + '/render.json';\n\n      getJSON(jsonFilename,\n        function(err, data) {\n          let scanState = [];\n          if (!err) {\n            try {\n              const metadata = JSON.parse(data);\n              console.log('Loaded metadata from ' + jsonFilename + ':', metadata);\n\n              // Read valid render.json parameters, if present\n              if (metadata.hasOwnProperty('state')) {\n                jsonToState(metadata.state, scanState);\n              }\n              if (metadata.hasOwnProperty('version')) {\n                scanState.brdfVersion = metadata.version;\n              }\n            } catch(e) {\n              err = 1;\n            }\n          }\n          if (err) {\n            console.log('Render metadata (' + jsonFilename + ') not loaded: ' + err);\n          }\n\n          mergeMetadata(scanState, keys);\n          loadScanFilenames(loadManager, texturePath);\n        }\n      );\n    }\n\n    function mergeMetadata(scanState, keys) {\n      let bivotState = [];\n\n      // Read valid bivot-renders.json parameters, if present\n      const curScan = _self.scans[_self.state.scan];\n      if (curScan.hasOwnProperty('cameraPositionX')) {\n        _self.camera.position.x = curScan.cameraPositionX;\n      }\n      if (curScan.hasOwnProperty('cameraPositionY')) {\n        _self.camera.position.y = curScan.cameraPositionY;\n      }\n      if (curScan.hasOwnProperty('cameraPositionZ')) {\n        _self.camera.position.z = curScan.cameraPositionZ;\n      }\n      if (curScan.hasOwnProperty('controlsMinDistance')) {\n        _self.controls.minDistance = curScan.controlsMinDistance;\n      }\n      if (curScan.hasOwnProperty('controlsMaxDistance')) {\n        _self.controls.maxDistance = curScan.controlsMaxDistance;\n      }\n      if (curScan.hasOwnProperty('state')) {\n        jsonToState(curScan.state, bivotState, _self.vectorKeys);\n      }\n      if (curScan.hasOwnProperty('version')) {\n        bivotState.brdfVersion = curScan.version;\n      }\n\n      mergeDictKeys(keys, _self.state, bivotState, scanState, _self.config.initialState, _self.vectorKeys);\n\n      console.log('  BRDF model: ', _self.state.brdfModel);\n      console.log('  BRDF version: ', _self.state.brdfVersion);\n\n      if (_self.opts.stateLoadCallback) {\n        _self.opts.stateLoadCallback(_self.state);\n      }\n    }\n\n    function loadScanFilenames(loadManager, texDir) {\n      let texNames = new Map();\n      if (_self.state.brdfModel == 1 && _self.state.brdfVersion >= 2.0) {\n        texNames.set('diffuse', 'basecolor');\n        texNames.set('normals', 'normals');\n        texNames.set('specular', 'roughness-metallic');\n      } else {\n        texNames.set('diffuse', 'diffuse');\n        texNames.set('normals', 'normals');\n        texNames.set('specular', 'specular-srt');\n      }\n\n      let paths = new Map();\n      console.assert(['JPG', 'PNG', 'EXR'].includes(_self.config.textureFormat));\n      if (_self.config.textureFormat == 'EXR') {\n        paths.set('diffuse', {path: texDir + '/brdf-' + texNames.get('diffuse') + '_cropf16.exr', format:THREE.RGBFormat});\n        paths.set('normals', {path: texDir + '/brdf-' + texNames.get('normals') + '_cropf16.exr', format:THREE.RGBFormat});\n        paths.set('specular', {path: texDir + '/brdf-' + texNames.get('specular') + '_cropf16.exr', format: THREE.RGBFormat});\n      }\n      else if (_self.config.textureFormat == 'JPG') {\n        paths.set('diffuse', {path: texDir + '/brdf-' + texNames.get('diffuse') + '_cropu8_hi.jpg', format:THREE.RGBFormat});\n        paths.set('normals', {path: texDir + '/brdf-' + texNames.get('normals') + '_cropu8_hi.jpg', format:THREE.RGBFormat});\n        paths.set('specular', {path: texDir + '/brdf-' + texNames.get('specular') + '_cropu8_hi.jpg', format: THREE.RGBFormat});\n      } else {\n        paths.set('diffuse', {path: texDir + '/brdf-' + texNames.get('diffuse') + '_cropu8_hi.png', format:THREE.RGBFormat});\n        paths.set('normals', {path: texDir + '/brdf-' + texNames.get('normals') + '_cropu8_hi.png', format:THREE.RGBFormat});\n        paths.set('specular', {path: texDir + '/brdf-' + texNames.get('specular') + '_cropu8_hi.png', format: THREE.RGBFormat});\n        if (_self.config.dual8Bit) {\n          paths.set('diffuse_low', {path: texDir + '/brdf-' + texNames.get('diffuse') + '_cropu8_lo.png', format:THREE.RGBFormat});\n          paths.set('normals_low', {path: texDir + '/brdf-' + texNames.get('normals') + '_cropu8_lo.png', format:THREE.RGBFormat});\n          paths.set('specular_low', {path: texDir + '/brdf-' + texNames.get('specular') + '_cropu8_lo.png', format: THREE.RGBFormat});\n        }\n      }\n\n      loadScansImpl(paths, texDir + '/brdf-mesh.obj', loadManager);\n    }\n\n    function onProgress(urlOfLastItemLoaded, itemsLoaded, itemsTotal) {\n      const progress = itemsLoaded / itemsTotal;\n      loadingElem.style.display = '';\n      progressBarElem.style.transform = `scaleX(${progress})`;\n    };\n\n    function getPlaneGeometry() {\n      const dpi = 300;\n      const pixelsPerMetre = dpi / 0.0254;\n      const textureWidthPixels = 2048;\n      const textureHeightPixels = 2048;\n      const planeWidth = textureWidthPixels / pixelsPerMetre;\n      const planeHeight = textureHeightPixels / pixelsPerMetre;\n      return new THREE.PlaneBufferGeometry(planeWidth, planeHeight);\n    }\n\n    function resizeRendererToDisplaySize() {\n      //_self.canvas.width = window.innerWidth;     // equals window dimension\n      //_self.canvas.height = window.innerHeight;\n      console.log('canvas:')\n      console.log(_self.canvas.width, _self.canvas.height)\n      const pixelRatio = window.devicePixelRatio || 1;\n      //const width  = _self.canvas.clientWidth  * pixelRatio;\n      //const height = _self.canvas.clientHeight * pixelRatio;\n      _self.canvas.width = _self.opts.width * pixelRatio;\n      _self.canvas.height = _self.opts.height * pixelRatio;\n\n      _self.canvas.style.width = _self.opts.width + 'px';\n      _self.canvas.style.height = _self.opts.height + 'px';\n\n      const width  = _self.canvas.clientWidth  | 0;\n      const height = _self.canvas.clientHeight | 0;\n      const needResize = _self.canvas.width !== width || _self.canvas.height !== height;\n      if (needResize) {\n        console.log(width, height);\n        //_self.renderer.setSize(width, height, false);\n      }\n      return needResize;\n    }\n\n    function fieldOfView(focalLength, sensorHeight) {\n      // Focal length is in mm for easier GUI control.\n      // Three.js defines the field of view angle as the vertical angle.\n      return 2 * Math.atan(sensorHeight / (2 * focalLength / 1000)) * 180 / Math.PI;\n    }\n\n    function updateFOV() {\n      fov = fieldOfView(_self.state.focalLength, sensorHeight);\n      _self.camera.fov = fov;\n      _self.camera.updateProjectionMatrix();\n      _self.requestRender();\n    }\n  }\n\n\n  initialiseCanvas(canvas, width, height) {\n    var w, h;\n    const parent = this.overlay;\n\n    if (!width || !height) {\n      w = parent.clientWidth;\n      h = parent.clientHeight;\n    } else {\n      w = width;\n      h = height;\n    }\n    const pixelRatio = window.devicePixelRatio || 1;\n    canvas.width = w * pixelRatio;\n    canvas.height = h * pixelRatio;\n    canvas.style.width = canvas.width / pixelRatio + 'px';\n    canvas.style.height = canvas.height / pixelRatio + 'px';\n\n  }\n\n  initialiseRenderer() {\n    var renderer = new THREE.WebGLRenderer({ canvas: this.canvas, preserveDrawingBuffer: true });\n    renderer.physicallyCorrectLights = true;\n\n    return renderer;\n  }\n\n  initialiseComposer(renderer, updateToneMapParams) {\n    var composer = new EffectComposer(renderer);\n\n    this.renderPass = new RenderPass(this.scene, this.camera);\n    composer.addPass(this.renderPass);\n\n    this.bloomPass = new UnrealBloomPass(\n      new THREE.Vector2(window.innerWidth, window.innerHeight),\n      this.state.bloom, // strength\n      0.4, // radius\n      0.99 // threshold\n    );\n    composer.addPass(this.bloomPass);\n\n    this.fxaaPass = new ShaderPass(FXAAShader);\n    this.setFxaaResolution();\n    composer.addPass(this.fxaaPass);\n\n    this.toneMappingPass = new AdaptiveToneMappingPass(true, 256);\n    updateToneMapParams();\n    composer.addPass(this.toneMappingPass);\n\n    // The effective gamma is hard-coded by the linear to sRGB mapping inside GammaCorrectionShader.\n    // To implement adjustable gamma, we could implement our own GammaCorrectionShader.\n    this.gammaCorrectPass = new ShaderPass(GammaCorrectionShader);\n    composer.addPass(this.gammaCorrectPass);\n\n\n    return composer;\n  }\n\n  isViewPortCoordInCanvas(x, y) {\n    if (!this.canvas) {\n      return false;\n    }\n    const rect = this.canvas.getBoundingClientRect();\n    return (x >= rect.left && x < rect.right &&\n            y >= rect.top  && y < rect.bottom);\n  }\n\n  updateLightingGrid() {\n    // FIXME: Ideally we should adjust exisiting lights to match new state, rather than just deleting them all\n    // and starting again. Although if it's fast to reconstruct the whole lighting state, that's actually\n    // safer from a state machine point of view.\n    if (this.lights) {\n      this.scene.remove(this.lights);\n    }\n    if (this.lights45) {\n      this.scene.remove(this.lights45);\n    }\n    // Our custom shader assumes the light colour is grey or white.\n    const color =\n        Math.round(0.5 * this.state.lightColor[0]) * 0x10000 +\n        Math.round(0.5 * this.state.lightColor[1]) * 0x100 +\n        Math.round(0.5 * this.state.lightColor[2]);\n    const totalIntensity = 1;\n    let totalLights = this.state.lightNumber ** 2;\n    if (this.state.light45) {\n      totalLights *= 2;\n    }\n    const lightIntensity = totalIntensity / (totalLights) * 2; // Doubled because color is halved (to allow colour range 0..2)\n    const distanceLimit = 10;\n    const decay = 2; // Set this to 2.0 for physical light distance falloff.\n\n    // Create a grid of lights in XY plane at z = length of lightPosition vector.\n    let upVector = new THREE.Vector3(0, 0, this.state.lightPosition.length());\n    let lights = new THREE.Group();\n    // We assume state.lightNumber is an odd integer.\n    let mid = this.state.lightNumber/2 - 0.5;\n    for (let i = 0; i < this.state.lightNumber; i++) {\n      for (let j = 0; j < this.state.lightNumber; j++) {\n        let offset = new THREE.Vector3(\n          (i - mid) * this.state.lightSpacing,\n          (j - mid) * this.state.lightSpacing,\n          0\n        );\n        if (this.state.lightType == 'area') {\n          let areaFactor = lightIntensity / (Math.atan(this.state.areaLightWidth) * Math.atan(this.state.areaLightHeight));\n          let rectLight = new THREE.RectAreaLight(color, areaFactor, this.state.areaLightWidth, this.state.areaLightHeight);\n          rectLight.position.copy(upVector);\n          rectLight.position.add(offset);\n          lights.add(rectLight);\n        } else {\n          let light = new THREE.PointLight(color, lightIntensity, distanceLimit, decay);\n          light.position.copy(upVector);\n          light.position.add(offset);\n          lights.add(light);\n        }\n      }\n    }\n    let upVectorNorm = upVector.clone();\n    upVectorNorm.normalize();\n    let lightVectorNorm = this.state.lightPosition.clone();\n    lightVectorNorm.normalize();\n    let rotationAxis = new THREE.Vector3(0, 0, 0);\n    rotationAxis.crossVectors(upVectorNorm, lightVectorNorm);\n    let rotationAngle = Math.acos(upVectorNorm.dot(lightVectorNorm));\n    lights.rotateOnAxis(rotationAxis, rotationAngle);\n    this.lights = lights;\n    this.scene.add(lights);\n\n    if (this.state.light45) {\n      // Add an extra light at 45 deg elevation for natural viewing on phone or tablet.\n      this.lights45 = lights.clone();\n      let xAxis = new THREE.Vector3(1, 0, 0);\n      this.lights45.rotateOnAxis(xAxis, Math.PI / 4);\n      this.scene.add(this.lights45);\n    } else {\n      this.lights45 = null;\n    }\n\n    this.requestRender();\n  }\n\n  updateCamsAndLightsFromXY(xy, light_sensitivity, cam_sensitivity) {\n    if (this.lights && light_sensitivity != 0.0) {\n      this.state.lightPosition.copy(\n        this.xyTo3dDirection(xy, this.state.lightPositionOffset, light_sensitivity, this.state.lightTiltLimitDegrees)\n      );\n      this.updateLightingGrid();\n    }\n    if (this.camera && cam_sensitivity != 0.0) {\n      // Retain existing camera distance\n      let camVec = this.xyTo3dDirection(xy, this.state._camPositionOffset, cam_sensitivity,\n        this.state.camTiltLimitDegrees);\n      this.camera.position.copy(camVec.multiplyScalar(this.camera.position.length()));\n      this.requestRender();\n    }\n  }\n\n  xyTo3dDirection(xy, offset, sensitivity, elevationLimit) {\n    // Convert input XY co-ords in range -1..1 and given sensitivity to a unit 3D direction vector\n    let new_xy = new THREE.Vector2();\n    // Clamp 2D length to elevation angle limit.\n    let qLimit = Math.cos(Math.PI * elevationLimit / 180);\n    new_xy.copy(xy).add(offset).multiplyScalar(sensitivity).clampLength(0.0, qLimit);\n    const z2 = 1 - new_xy.lengthSq();\n    let new_z = 0.0;\n    if (z2 > 0.0) {\n      new_z = Math.sqrt(z2);\n    }\n    console.assert(!isNaN(new_z));\n    return new THREE.Vector3(new_xy.x, new_xy.y, new_z);\n  }\n\n\n  updateMeshRotation() {\n    if (this.mesh) {\n      this.mesh.rotateZ((this.state.meshRotateZDegrees - this.state._meshRotateZDegreesPrevious)*Math.PI/180);\n      this.state._meshRotateZDegreesPrevious = this.state.meshRotateZDegrees;\n    }\n  }\n\n  // Update all rendering dimensions to conform with canvas.width and canvas.height\n  updateCanvas() {\n    if (this.canvas) {\n      const pixelRatio = window.devicePixelRatio || 1;\n\n      this.canvas.style.width = this.canvas.width / pixelRatio + 'px';\n      this.canvas.style.height = this.canvas.height / pixelRatio + 'px';\n\n      this.renderer.setSize(this.canvas.width, this.canvas.height, false);\n      this.camera.aspect = this.canvas.width / this.canvas.height;\n      this.camera.updateProjectionMatrix();\n      this.composer.setSize(this.canvas.width, this.canvas.height);\n      this.setFxaaResolution();\n    }\n  }\n\n  getBgColorFromState(state) {\n    var bg;\n    if (state.backgroundColor) {\n      bg = parseInt(state.backgroundColor.replace('#', '0x'));\n    } else {\n      bg = state.background * 0x010101;\n    }\n    return bg;\n  }\n\n  updateBackground() {\n    this.scene.background = new THREE.Color(this.getBgColorFromState(this.state));\n    this.requestRender();\n  }\n\n  updateZoom() {\n    if (this.controls) {\n      this.controls.minDistance = this.state.zoom[0];\n      this.controls.maxDistance = this.state.zoom[2];\n    }\n\n    if (this.camera) {\n      // Retain existing camera angle, changing the distance\n      const ratio = this.state.currentZoom / this.camera.position.length();\n      this.camera.position.copy(this.camera.position.multiplyScalar(ratio));\n    }\n    this.requestRender();\n  }\n\n  setFxaaResolution() {\n    var fxaaUniforms = this.fxaaPass.material.uniforms;\n    const pixelRatio = this.renderer.getPixelRatio();\n    var val = 1.0 / pixelRatio;\n    if (!this.state.fxaa) {\n      val = 0.0;\n    }\n    fxaaUniforms['resolution'].value.x = val / window.innerWidth; // FIXME: Should be canvas width?\n    fxaaUniforms['resolution'].value.y = val / window.innerHeight; // FIXME: Should be canvas height?\n  }\n\n  updateAutoRotate(loopValue) {\n    if (!this.mouseInCanvas || this.state.lightMotion == 'animate') {\n      // loopValue is between 0 and 1\n      const angle = 2 * Math.PI * loopValue;\n      const xy = new THREE.Vector2(\n        -Math.sin(angle),\n        Math.cos(angle)\n      );\n      const camSensitivity = -0.3 * this.state.autoRotateCamFactor;\n      const lightSensitivity = 1.0 * this.state.autoRotateLightFactor;\n\n      this.timeouts.push(\n        setTimeout(\n          () => this.updateCamsAndLightsFromXY(xy, lightSensitivity, camSensitivity),\n          1000 / this.state.autoRotateFps\n        )\n      );\n    }\n  }\n\n  render(timeMs) {\n    if (this.shuttingDown) {\n      this.doShutdown();\n    } else if (this.controls && this.composer) {\n      if (this.state.dirty) {\n        this.state.dirty = false;\n        this.updateBackground();\n        this.updateLightingGrid();\n        this.updateMeshRotation();\n        this.updateCanvas();\n        this.updateZoom();\n      }\n\n      this.controls.update();\n\n      if (this.state.autoRotatePeriodMs \n        && (this.state.lightMotion == 'mouse' || this.state.lightMotion == 'animate')) {\n        this.updateAutoRotate((timeMs % this.state.autoRotatePeriodMs) / this.state.autoRotatePeriodMs);\n      }\n\n      this.uniforms.uExposure.value = this.exposureGain * this.state.exposure;\n      this.uniforms.uBrightness.value = this.state.brightness;\n      this.uniforms.uContrast.value = this.state.contrast;\n      this.uniforms.uDiffuse.value = this.state.diffuse;\n      this.uniforms.uSpecular.value = this.state.specular;\n      this.uniforms.uRoughness.value = this.state.roughness;\n      this.uniforms.uTint.value = this.state.tint;\n      this.uniforms.uFresnel.value = this.state.fresnel;\n      this.uniforms.uThreeJsShader.value = this.state.threeJsShader;\n      this.uniforms.uBrdfModel.value = this.state.brdfModel;\n      this.uniforms.uBrdfVersion.value = this.state.brdfVersion;\n      this.uniforms.uLoadExr.value = (this.config.textureFormat == 'EXR');\n      this.uniforms.uDual8Bit.value = this.config.dual8Bit;\n      this.uniforms.ltc_1.value = THREE.UniformsLib.LTC_1;\n      this.uniforms.ltc_2.value = THREE.UniformsLib.LTC_2;\n\n      this.composer.render();\n\n      this.renderRequested = false;\n    }\n  }\n\n  // Request a render frame only if a request is not already pending.\n  requestRender() {\n    if (!this.renderRequested && this.render) {\n      this.renderRequested = true;\n      requestAnimationFrame(this.render.bind(this));\n    }\n  }\n\n  checkWebGL() {\n    if (WEBGL.isWebGLAvailable() === false) {\n      document.body.appendChild(WEBGL.getWebGLErrorMessage());\n    }\n  }\n\n\n  registerEventListener(object, type, listener, ...args) {\n    object.addEventListener(type, listener, ...args);\n    this.listeners.push({ object, type, listener });\n  }\n\n  registerElement(document, tagName) {\n    const element = document.createElement(tagName);\n    this.elements.push(element);\n    return element;\n  }\n\n  shutdown() {\n    this.shuttingDown = true;\n  }\n\n  doShutdown() {\n    for (var i = 0; i < this.timeouts.length; i++) {\n      clearTimeout(this.timeouts[i]);\n    }\n    this.timeouts = [];\n\n    for (var i = 0; i < this.listeners.length; i++) {\n      const { object, type, listener } = this.listeners[i];\n      object.removeEventListener(type, listener);\n    }\n    this.listeners = [];\n\n    for (var i = 0; i < this.elements.length; i++) {\n      const elem = this.elements[i];\n      elem.parentNode.removeChild(elem);\n    }\n    this.elements = [];\n\n    this.canvas = null;\n    this.overlay = null;\n  }\n}\n\n\nexport default bivotJs;\n","// Copyright (C) Bandicoot Imaging Sciences 2019\n'use strict';\n\n// The Three.js import paths in bivot.js and shaers.js need to match.\n\nimport * as THREE from 'https://cdn.jsdelivr.net/gh/bandicoot-imaging-sciences/three.js@ddd1af2abc1217f3ecab597f951becf74bf0190c/build/three.module.js';\n\nexport default function getShaders() {\n  const uniforms = THREE.UniformsUtils.merge([\n      THREE.UniformsLib.lights,\n      {\n        // Set textures to null here and assign later to avoid duplicating texture data.\n        'diffuseMap': {value: null},\n        'normalMap': {value: null}, // Three.js shader chunks assume normal map is called normalMap.\n        'specularMap': {value: null},\n        'normalScale': { value: new THREE.Vector2( 1, 1 ) }, // Three.js shader chunks: scaling for xy normals.\n        'uExposure': {value: 1.0},\n        'uDiffuse': {value: 1.0},\n        'uSpecular': {value: 1.0},\n        'uRoughness': {value: 1.0},\n        'uTint': {value: true},\n        'uFresnel': {value: false},\n        'uBrdfModel': {value: 0}, // 0: BIS; 1: M/R\n        'uThreeJsShader': {value: false},\n        'uBrdfVersion': {value: 2.0},\n        'uLoadExr': {value: false},\n        'uDual8Bit': {value: false},\n        'diffuseMapLow': {value: null},  // Low byte when dual 8-bit textures are loaded\n        'normalMapLow': {value: null},   // Low byte when dual 8-bit textures are loaded\n        'specularMapLow': {value: null}, // Low byte when dual 8-bit textures are loaded\n        'ltc_1': {value: null}, // Linearly Transformed Cosines look-up table 1 for area lighting\n        'ltc_2': {value: null}, // Linearly Transformed Cosines look-up table 2 for area lighting\n        'uBrightness': {value: 1.0},\n        'uContrast': {value: 0.5},\n      }\n    ]);\n\n  const glsl = x => x.toString(); // No-op to trigger GLSL syntax highlighting in VS Code with glsl-literal extension.\n  const vertexShader = glsl`\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 vViewPosition;\n\n    void main() {\n      vec4 worldPosition = modelMatrix*vec4(position, 1.0);\n\n      vUv = uv;\n      // Alternatively this might be needed if we are scaling the texture:\n      // vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n      #include <beginnormal_vertex>\n      #include <defaultnormal_vertex>\n\n      vNormal = normalize(transformedNormal);\n\n      #include <begin_vertex>\n      #include <project_vertex>\n\n      vViewPosition = - mvPosition.xyz;\n    }\n    `;\n\n  const fragmentShader = glsl`\n    uniform sampler2D diffuseMap;\n    // Defined in <normalmap_pars_fragment>\n    // uniform sampler2D normalMap;\n    uniform sampler2D specularMap;\n\n    uniform sampler2D diffuseMapLow;\n    uniform sampler2D normalMapLow;\n    uniform sampler2D specularMapLow;\n\n    uniform float uExposure;\n    uniform float uBrightness;\n    uniform float uContrast;\n    uniform float uDiffuse;\n    uniform float uSpecular;\n    uniform float uRoughness;\n    uniform bool  uTint;\n    uniform bool  uFresnel;\n    uniform bool  uThreeJsShader;\n\n    uniform int   uBrdfModel;\n    uniform float uBrdfVersion;\n    uniform bool  uDual8Bit;\n    uniform bool  uLoadExr;\n\n    varying vec3 vNormal;\n    varying vec3 vTangent;\n    varying vec3 vBitangent;\n    varying vec2 vUv;\n    varying vec3 vViewPosition;\n\n    float pi = 3.14159265359;\n\n    #include <common>\n    #include <bsdfs>\n    #include <packing>\n    #include <lights_pars_begin>\n    #include <normalmap_pars_fragment>\n    #include <lights_physical_pars_fragment>\n\n    float calcLightAttenuation(float lightDistance, float cutoffDistance, float decayExponent) {\n      if (decayExponent > 0.0) {\n        // The common ShaderChunk includes: #define saturate(a) clamp( a, 0.0, 1.0 )\n        return pow(saturate(-lightDistance/cutoffDistance + 1.0), decayExponent);\n      }\n      return 1.0;\n    }\n\n    float DisneySpecular(float specular, float roughness, float ndh, float s) {\n      // TODO: Add episilon to fragile denominators.\n      float r4 = pow(roughness, 4.0);\n      float k = 1.0 - r4;\n      float c = (1.0/(s*PI))*((1.0/r4 + (1.0/(2.0*sqrt(k))*log((sqrt(k) + k)/(sqrt(k) - k)))));\n      float denom = pow((1.0 + (r4 - 1.0)*pow(ndh, 2.0)), 2.0);\n      return (specular)/(c*denom);\n    }\n\n    float MRSpecular(float roughness, float ndh, float ndl, float ndv) {\n      float r2 = roughness * roughness;\n\n      // Substance Designer uses a different expression for visibility:\n      //   float k = r2 / 2.0;\n      //   float visibility = 1.0 / (4.0 * (ndl * (1.0 - k) + k) * (ndv * (1.0 - k) + k));\n\n      // Three.js\n      //   The following code should be equivalent to calling:\n      //     return G_GGX_Smith(r2, ndl, ndv) * D_GGX(r2, ndh);\n      float k = r2 * r2;\n      float gl = ndl + sqrt(ndv*ndv * (1.0 - k) + k);\n      float gv = ndv + sqrt(ndl*ndl * (1.0 - k) + k);\n      float visibility = 1.0 / (gl * gv);\n      //float visibility = 0.25;\n      float t = r2 / (1.0 + (r2 * r2 - 1.0) * ndh*ndh);\n      return visibility * t*t / pi;\n    }\n\n\n    void main() {\n      vec4 diffuseSurface = texture2D(diffuseMap, vUv);\n      vec3 normalSurface = texture2D(normalMap, vUv).xyz;\n      vec4 specularTexel = texture2D(specularMap, vUv);\n\n      if (uDual8Bit) {\n        vec4 diffuseSurfaceLow = texture2D(diffuseMapLow, vUv) / 256.0;\n        vec3 normalSurfaceLow = texture2D(normalMapLow, vUv).xyz / 256.0;\n        vec4 specularTexelLow = texture2D(specularMapLow, vUv) / 256.0;\n\n        diffuseSurface = diffuseSurface + diffuseSurfaceLow;\n        normalSurface = normalSurface + normalSurfaceLow;\n        specularTexel = specularTexel + specularTexelLow;\n      }\n\n      float s = 1.0;\n      float white_L = 1.0;\n      float specularSurface = 0.0;\n      float roughnessSurface = 0.0;\n      float tintSurface = 0.0;\n      float metallicSurface = 0.0;\n\n      if (uBrdfModel == 1) {\n        // (M/R model)\n        white_L = 16383.0;\n        roughnessSurface = specularTexel.r;\n        metallicSurface = specularTexel.g;\n      } else {\n        // uBrdfModel == 0 (BIS model)\n        specularSurface = specularTexel.r;\n        roughnessSurface = specularTexel.g;\n        if (uTint && uBrdfVersion >= 2.0) {\n          tintSurface = specularTexel.b;\n        }\n        if (uBrdfVersion >= 2.0) {\n          s = 65535.0*0.01;\n        }\n\n        if (uLoadExr) {\n          if (uBrdfVersion == 3.0) {\n            diffuseSurface *= 16383.0;\n          }\n        } else {\n          diffuseSurface *= 65535.0;\n        }\n      }\n\n      if (uThreeJsShader && uBrdfModel == 1) {\n        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n        vec4 diffuseColor = diffuseSurface;\n        float metalnessFactor = metallicSurface;\n        float roughnessFactor = uRoughness * roughnessSurface;\n        #include <normal_fragment_begin>\n        #include <normal_fragment_maps>\n        #include <lights_physical_fragment>\n        #include <lights_fragment_begin>\n        #include <lights_fragment_maps>\n        #include <lights_fragment_end>\n\n        // Ambient light is calculated automatically as part of reflectedLight.indirectDiffuse\n        //vec3 ambientFactor = diffuseSurface.rgb * ambientLightColor;\n        vec3 diffuseFactor = uDiffuse * (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);\n        vec3 specularFactor = uSpecular * (reflectedLight.directSpecular + reflectedLight.indirectSpecular);\n        vec3 outgoingLight = white_L * uExposure * (diffuseFactor + specularFactor);\n        gl_FragColor = vec4((uContrast * (outgoingLight * 2.0 - 1.0) + 0.5) + 2.0 * uBrightness - 1.0, diffuseColor.a);\n      } else {\n        vec3 macroNormal = normalize(vNormal);\n        //vec3 mesoNormal = normal;  // Enable for tangent-space normal map\n        vec3 mesoNormal = normalize(normalMatrix * (normalSurface * 2.0 - 1.0));  // For object space normal map\n        vec3 viewerDirection = normalize(vViewPosition);\n        float ndv = max(dot(mesoNormal, viewerDirection), 0.0);\n\n        vec3 totalSpecularLight = vec3(0.0);\n        vec3 totalDiffuseLight = vec3(0.0);\n\n#if NUM_POINT_LIGHTS > 0\n        vec3 pointSpecularColor;\n        vec3 pointDiffuseColor;\n        vec3 pointAmbientColor;\n        float diffuseSurfaceMean = dot(diffuseSurface.rgb, vec3(1.0))/3.0;\n        if (uBrdfModel == 1) {  // [Three.js MR]\n          pointSpecularColor = diffuseSurface.rgb * metallicSurface + 0.04 * (1.0 - metallicSurface);\n          pointDiffuseColor = diffuseSurface.rgb * (1.0 - metallicSurface);\n          // Substance Designer:\n          //pointDiffuseColor = diffuseSurface.rgb * (1.0 - metallicSurface) * (1.0 - pointSpecularColor);\n          pointAmbientColor = ambientLightColor;\n        } else {                // [BIS Disney]]\n          pointSpecularColor = (diffuseSurface.rgb/diffuseSurfaceMean)*tintSurface + (1.0 - tintSurface);\n          pointDiffuseColor = diffuseSurface.rgb * pi; // Convert to physically correct lighting\n          pointAmbientColor = ambientLightColor * pi;  // Convert to physically correct lighting\n        }\n        for (int i = 0; i < NUM_POINT_LIGHTS; i ++) {\n          vec3 lVector = pointLights[i].position + vViewPosition.xyz;\n          lVector = normalize(lVector);\n          vec3 halfVector = normalize(lVector + viewerDirection);\n          float ndh = dot(mesoNormal, halfVector);\n          float ndl = max(dot(mesoNormal, lVector), 0.0);\n\n          float attenuation;\n          float pointSpecularWeight;\n          if (uBrdfModel == 1) {  // [Three.js MR]\n            attenuation = punctualLightIntensityToIrradianceFactor(length(lVector), pointLights[i].distance, pointLights[i].decay);\n            pointSpecularWeight = uSpecular * MRSpecular(uRoughness * roughnessSurface, ndh, ndl, ndv);\n            if (uFresnel) {\n              float vdh = dot(viewerDirection, halfVector);\n              pointSpecularColor = F_Schlick(pointSpecularColor, vdh);\n            }\n          } else {                // [BIS Disney]\n            attenuation = calcLightAttenuation(length(lVector), pointLights[i].distance, pointLights[i].decay);\n            pointSpecularWeight = DisneySpecular(uSpecular*specularSurface, uRoughness*roughnessSurface, ndh, s) / ndl;\n            // FIXME: This assumes the light colour is white or grey.\n            pointSpecularWeight *= pointLights[i].color.r;\n          }\n\n          vec3 irradiance = ndl * attenuation * pointLights[i].color;\n          totalDiffuseLight += pointDiffuseColor * irradiance / pi;\n          totalSpecularLight += pointSpecularWeight * pointSpecularColor * irradiance;\n        }\n        vec3 ambientContrib = pointDiffuseColor * pointAmbientColor / pi;\n#else\n        vec3 ambientContrib = vec3(0.0);\n#endif\n\n        vec3 outgoingLight = white_L * uExposure *\n            (ambientContrib + uDiffuse*totalDiffuseLight + totalSpecularLight);\n\n        gl_FragColor = vec4((uContrast * (outgoingLight * 2.0 - 1.0) + 0.5) + 2.0 * uBrightness - 1.0, 1.0);\n      }\n    }\n  `;\n\n  return { uniforms, vertexShader, fragmentShader };\n}\n","\n// Return true if the given object has no properties\nexport function isEmpty(obj) {\n  for(var key in obj) {\n      if(obj.hasOwnProperty(key))\n          return false;\n  }\n  return true;\n}\n","import bivotJs from './bivot.js';\nimport './bivot.css';\n\nexport function newBivot(options) {\n  return new bivotJs(options);\n}\n"],"names":["Symbol","iterator","asyncIterator","loadJsonFile","url","parsed","body","recover","result","loadJsonFilePromise","p","JSON","parse","e","then","promise","Promise","resolve","reject","req","XMLHttpRequest","open","overrideMimeType","onload","status","response","statusText","onerror","send","jsonToState","inDict","outDict","vectorKeys","key","lightPosition","THREE","lightPositionOffset","t","undefined","input","vecType","output","console","assert","Array","isArray","fromArray","copyStatesCloneVectors","src","dst","k","clone","bivotJs","options","this","controlModes","FULL","QA","MANAGE","NONE","glsl","x","toString","uniforms","merge","lights","diffuseMap","value","normalMap","specularMap","normalScale","uExposure","uDiffuse","uSpecular","uRoughness","uTint","uFresnel","uBrdfModel","uThreeJsShader","uBrdfVersion","uLoadExr","uDual8Bit","diffuseMapLow","normalMapLow","specularMapLow","ltc_1","ltc_2","uBrightness","uContrast","vertexShader","fragmentShader","opts","canvasID","overlayID","configPath","renderPath","texturePath","config","material","textures","materialSet","controlMode","useTouch","width","height","state","stateLoadCallback","setZoomCallback","exposure","brightness","contrast","focalLength","diffuse","specular","roughness","tint","fresnel","ambient","fxaa","bloom","adaptiveToneMap","toneMapDarkness","threeJsShader","lightType","areaLightWidth","areaLightHeight","lightMotion","lightColor","lightNumber","lightSpacing","light45","scan","brdfModel","brdfVersion","yFlip","background","backgroundColor","meshRotateZDegrees","camTiltWithMousePos","camTiltWithDeviceOrient","camTiltLimitDegrees","lightTiltWithMousePos","lightTiltWithDeviceOrient","lightTiltLimitDegrees","tiltDriftSpeed","tiltZeroOnMouseOut","portrait","autoRotatePeriodMs","autoRotateFps","autoRotateCamFactor","autoRotateLightFactor","_camPositionOffset","_meshRotateZDegreesPrevious","_statusText","textureFormat","loadExr","loadPng","loadJpeg","dual8Bit","showInterface","mouseCamControlsZoom","mouseCamControlsRotate","mouseCamControlsPan","initCamZ","minCamZ","maxCamZ","linearFilter","initialState","hasOwnProperty","canvas","document","getElementById","overlay","scans","materials","exposureGain","renderRequested","scene","camera","lights45","mesh","renderer","fxaaPass","toneMappingPass","renderPass","bloomPass","gammaCorrectPass","composer","controls","mouseInCanvas","shuttingDown","timeouts","listeners","elements","startRender","_self","fov","ambientLight","gyroDetected","touchDetected","window","matchMedia","matches","baselineTilt","baselineTiltSet","loader","firstRenderLoaded","brdfTextures","loadingElem","progressBarElem","subtitleElem","subtitleTextElem","orientPermNeeded","DeviceOrientationEvent","requestPermission","orientPermWanted","orientPermObtained","iOSVersion","iOSVersionOrientBlocked","iOSVersionTimeoutID","test","navigator","userAgent","match","substr","split","map","n","parseInt","urlFlags","validFlags","show","showcase","dict","URL","location","href","searchParams","decodeValue","decodeURI","validValues","includes","warn","log","getUrlFlags","onLoad","style","display","get","defines","USE_NORMALMAP","OBJECTSPACE_NORMALMAP","extensions","derivatives","traverse","child","add","setTimeout","updateStatusTextDisplay","push","registerEventListener","clearTiltWarning","updateLightingGrid","requestRender","updateToneMapParams","setAdaptive","setAverageLuminance","controlsChange","event","position","length","detectGyro","alpha","beta","gamma","removeEventListener","updateLightMotion","requestTiltPermission","permissionState","catch","error","clearTimeout","requestButton","registerElement","className","innerHTML","onclick","appendChild","onDeviceOrientation","onDocumentMouseMove","onDocumentMouseOut","onCanvasMouseOver","onCanvasMouseOut","preventDefault","viewPortX","clientX","viewPortY","clientY","isViewPortCoordInCanvas","rect","getBoundingClientRect","xy","left","right","top","bottom","updateCamsAndLightsFromXY","set","y","copy","xyTo3dDirection","currentTilt","orient","orientation","rotation","getOrientation","deltaTilt","sub","Math","sin","degToRad","elevationLimit","max","qLimit","cos","surplus","clampLength","addScaledVector","newMeshRotation","updateMeshRotation","loadScansImpl","brdfTexturePaths","meshPath","loadManager","OBJLoader","load","object","geometry","computeVertexNormals","xhr","Map","path","pop","toUpperCase","EXRLoader","onProgress","texture","textureData","minFilter","magFilter","name","flipY","format","loadScanFromTextures","keys","paths","basecolor","normals","scanState","metadata","renders","version","mergeMetadata","bivotState","curScan","cameraPositionX","cameraPositionY","z","cameraPositionZ","minDistance","controlsMinDistance","maxDistance","controlsMaxDistance","out","first","second","third","forEach","item","index","mergeDictKeys","urlOfLastItemLoaded","itemsLoaded","itemsTotal","progress","transform","Object","values","indexOf","obj","isEmpty","configFilename","optsConfig","jsonConfig","loadConfig","renderFilename","jsonRender","r","loadRender","filename","jsonMaterialSet","numMaterials","i","galleryMats","gallery","galleryMat","render","bivotMat","[object Object]","bivotMatRender","loadMaterialSet","initConfig","zoomArray","tiltLimit","_this","loadingDiv","progressDiv","progressBarDiv","subtitleDiv","subtitleBGDiv","subtitleTextP","initialiseOverlays","getBgColorFromState","initZ","sensorHeight","atan","PI","fieldOfView","initialiseCamera","OrbitControls","enableDamping","dampingFactor","panSpeed","rotateSpeed","zoomSpeed","target","update","enableZoom","enableRotate","enablePan","screenSpacePanning","dispose","limitDeg","tiltLimitRadians","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","updateCamTiltLimit","initialiseCanvas","initialiseRenderer","RectAreaLightUniformsLib","init","initialiseComposer","updateCanvas","remove","loadScanFromMaterial","callback","jsonFilename","err","data","texDir","texNames","loadScanFilenames","loadScanMetadata","loadScan","zoom","currentZoom","updateZoom","w","h","parent","clientWidth","clientHeight","pixelRatio","devicePixelRatio","preserveDrawingBuffer","physicallyCorrectLights","EffectComposer","RenderPass","addPass","UnrealBloomPass","innerWidth","innerHeight","ShaderPass","FXAAShader","setFxaaResolution","AdaptiveToneMappingPass","GammaCorrectionShader","color","round","totalLights","lightIntensity","upVector","mid","j","offset","areaFactor","rectLight","light","upVectorNorm","normalize","lightVectorNorm","rotationAxis","crossVectors","rotationAngle","acos","dot","rotateOnAxis","xAxis","light_sensitivity","cam_sensitivity","camVec","multiplyScalar","sensitivity","new_xy","z2","lengthSq","new_z","sqrt","isNaN","rotateZ","setSize","aspect","updateProjectionMatrix","replace","updateBackground","ratio","fxaaUniforms","val","getPixelRatio","updateAutoRotate","loopValue","angle","camSensitivity","lightSensitivity","_this2","timeMs","doShutdown","dirty","LTC_1","LTC_2","requestAnimationFrame","bind","checkWebGL","WEBGL","isWebGLAvailable","getWebGLErrorMessage","type","listener","args","addEventListener","tagName","element","createElement","shutdown","elem","parentNode","removeChild","newBivot"],"mappings":"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"}